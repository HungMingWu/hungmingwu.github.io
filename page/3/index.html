<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="第十三號艦隊">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="第十三號艦隊">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="HungMingWu">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>第十三號艦隊</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">第十三號艦隊</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="archive fa-fw"></i>Archives</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="th fa-fw"></i>Categories</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="tags fa-fw"></i>Tags</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="user fa-fw"></i>About</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/HungMingWu" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2023/08/15/static-assert-false-in-C-23/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="HungMingWu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="第十三號艦隊">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/08/15/static-assert-false-in-C-23/" class="post-title-link" itemprop="url">static_assert(false) in C++23</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-08-15 15:47:05" itemprop="dateCreated datePublished" datetime="2023-08-15T15:47:05+00:00">2023-08-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-10-06 01:47:17" itemprop="dateModified" datetime="2025-10-06T01:47:17+00:00">2025-10-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>出去玩了一趟，好久沒寫一些東西，不然都要乾涸了<br>這觀念也很簡單，假設我們有類似這樣的程式碼</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="built_in">std</span>::is_same_v&lt;T, <span class="keyword">int</span>&gt;)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// handle int case</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">constexpr</span> (<span class="built_in">std</span>::is_same_v&lt;T, <span class="keyword">float</span>&gt;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// handle float case</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... other cases</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">static_assert</span>(<span class="literal">false</span>, <span class="string">"T not supported"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這段程式在C++20是編譯不過，可是C++23放鬆了限制，允許這種寫法<br>不過根據神人的解法，在C++20可以模擬這種動作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">constexpr</span> <span class="title">bool</span> <span class="title">always_false</span> = <span class="title">false</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="built_in">std</span>::is_same_v&lt;T, <span class="keyword">int</span>&gt;)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// handle int case</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> <span class="keyword">constexpr</span> (<span class="built_in">std</span>::is_same_v&lt;T, <span class="keyword">float</span>&gt;)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// handle float case</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... other cases</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">static_assert</span>(always_false&lt;T&gt;, <span class="string">"T not supported"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>雖然繞了一點，但是能用</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li><a href="https://artificial-mind.net/blog/2020/10/03/always-false" target="_blank" rel="noopener">always_false</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2023/02/26/Story-about-type-punning/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="HungMingWu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="第十三號艦隊">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/26/Story-about-type-punning/" class="post-title-link" itemprop="url">Story about type punning</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-26 09:02:24" itemprop="dateCreated datePublished" datetime="2023-02-26T09:02:24+00:00">2023-02-26</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-10-06 01:47:17" itemprop="dateModified" datetime="2025-10-06T01:47:17+00:00">2025-10-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="What-is-type-punning"><a href="#What-is-type-punning" class="headerlink" title="What is type punning"></a>What is type punning</h3><p>Type Punning是指用不同類型的Pointer，指向同一塊Memory address的行為，這是Undefined beahvior，可能會造成未知的錯誤．<br>例如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">float</span> f = <span class="number">3.14</span>;</span><br><span class="line">	<span class="keyword">int</span>* pi = (<span class="keyword">int</span>*)&amp;f; </span><br><span class="line">	*pi = <span class="number">42</span>; </span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"f = "</span> &lt;&lt; f &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; </span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Type punning違反了<code>Strict aliasing rule</code></p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>寫網路程式的時候常常會遇到這種情形，分配一塊記憶體，然後Cast成另外一種Type的Pointer填值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Msg</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> b;</span><br><span class="line">&#125; Msg;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SendWord</span><span class="params">(<span class="keyword">uint32_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Get a 32-bit buffer from the system</span></span><br><span class="line">    <span class="keyword">uint32_t</span>* buff = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Msg));</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Alias that buffer through message</span></span><br><span class="line">    Msg* msg = (Msg*)(buff);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// Send a bunch of messages    </span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        msg-&gt;a = i;</span><br><span class="line">        msg-&gt;b = i+<span class="number">1</span>;</span><br><span class="line">        SendWord(buff[<span class="number">0</span>]);</span><br><span class="line">        SendWord(buff[<span class="number">1</span>]);   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h3><h4 id="C-Solution"><a href="#C-Solution" class="headerlink" title="C Solution"></a>C Solution</h4><h5 id="union"><a href="#union" class="headerlink" title="union"></a>union</h5><p>C語言的話可以使用<code>union</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">union</span> &#123;</span><br><span class="line">  Msg msg;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">int</span> asBuffer[<span class="keyword">sizeof</span>(Msg)/<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span>)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5 id="char"><a href="#char" class="headerlink" title="char*"></a>char*</h5><p>或是使用<code>(unisnged / signed) char *</code>取代上面的<code>int*</code><br>可以認為j從<code>char*</code>轉匯成<code>type *</code>是合法的，反之不成立</p>
<h5 id="memcpy"><a href="#memcpy" class="headerlink" title="memcpy"></a>memcpy</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x = <span class="number">42</span>; </span><br><span class="line"><span class="keyword">float</span> y; </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">memcpy</span>(&amp;y, &amp;x, <span class="keyword">sizeof</span>(x));</span><br></pre></td></tr></table></figure>
<p>這樣是合法的，不過缺點就是要多一次拷貝</p>
<h4 id="C-Solution-1"><a href="#C-Solution-1" class="headerlink" title="C++ Solution"></a>C++ Solution</h4><h5 id="bit-cast"><a href="#bit-cast" class="headerlink" title="bit_cast"></a>bit_cast</h5><p>C++20引進的新東西，不過實作也就只是上面的memcpy包裝</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">To</span>, <span class="title">class</span> <span class="title">From</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bit_cast</span>(<span class="title">const</span> <span class="title">From</span>&amp; <span class="title">src</span>) <span class="title">noexcept</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    To dst;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">memcpy</span>(&amp;dst, &amp;src, <span class="keyword">sizeof</span>(To));</span><br><span class="line">    <span class="keyword">return</span> dst;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="std-start-lifetime-as"><a href="#std-start-lifetime-as" class="headerlink" title="std::start_lifetime_as"></a>std::start_lifetime_as</h5><p>C++23引進的新觀念，類似於reinterpret_cast，不過沒有undefined behaviro的副作用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ProtocolHeader</span> &#123;</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> version;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> msg_type;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">char</span> chunks_count;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ReceiveData</span><span class="params">(<span class="built_in">std</span>::span&lt;<span class="built_in">std</span>::byte&gt; data_from_net)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data_from_net.size() &lt; <span class="keyword">sizeof</span>(ProtocolHeader)) <span class="keyword">throw</span> SomeException();</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">auto</span>* header = <span class="built_in">std</span>::start_lifetime_as&lt;ProtocolHeader&gt;(</span><br><span class="line">        data_from_net.data()</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">switch</span> (header-&gt;type) &#123;&gt;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li><a href="https://stackoverflow.com/questions/98650/what-is-the-strict-aliasing-rule" target="_blank" rel="noopener">What is the strict aliasing rule?</a></li>
<li><a href="https://en.cppreference.com/w/cpp/numeric/bit_cast" target="_blank" rel="noopener">std::bit_cast</a></li>
<li><a href="https://medium.com/yandex/c-23-feature-freeze-summer-iso-wg21-meeting-results-bc79d03668b3" target="_blank" rel="noopener">C++23 Feature Freeze: Summer ISO WG21 Meeting Results</a></li>
<li><a href="https://xyfu.me/posts/326396eb/" target="_blank" rel="noopener">Type Punning)</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2023/02/11/GAT-equivalence-in-C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="HungMingWu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="第十三號艦隊">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2023/02/11/GAT-equivalence-in-C/" class="post-title-link" itemprop="url">GAT equivalence in C++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2023-02-11 06:35:12" itemprop="dateCreated datePublished" datetime="2023-02-11T06:35:12+00:00">2023-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-10-06 01:47:17" itemprop="dateModified" datetime="2025-10-06T01:47:17+00:00">2025-10-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>一開始看到GAT也不知道在幹嘛，是看到<a href="https://old.reddit.com/r/rust/comments/ynvm8a/could_someone_explain_the_gats_like_i_was_5" target="_blank" rel="noopener">Could someone explain the GATs like I was 5?</a>才有感覺]<br>最簡單的範例，現在有一個struct</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span></span> &#123; bar: Rc&lt;<span class="built_in">String</span>&gt;, &#125;</span><br></pre></td></tr></table></figure>
<p>假設你要同時支援 <code>Rc</code>和’<code>Arc</code>的版本<br>該怎麼做</p>
<h3 id="Naive-solution"><a href="#Naive-solution" class="headerlink" title="Naive solution"></a>Naive solution</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FooRc</span></span> &#123; bar: Rc&lt;<span class="built_in">String</span>&gt;, &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FooArc</span></span> &#123; bar: Arc&lt;<span class="built_in">String</span>&gt;, &#125;</span><br></pre></td></tr></table></figure>
<p>不過這當然沒什麼好說的</p>
<h3 id="Macro-solution"><a href="#Macro-solution" class="headerlink" title="Macro solution"></a>Macro solution</h3><p>理論上辦得到，不過沒什麼優點</p>
<h3 id="GAT-Solution"><a href="#GAT-Solution" class="headerlink" title="GAT Solution"></a>GAT Solution</h3><p>我希望能寫成這樣</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span></span>&lt;P: Pointer&gt; &#123; bar: P&lt;<span class="built_in">String</span>&gt;, &#125;</span><br></pre></td></tr></table></figure>
<p>這樣是編譯不會過的，有了GAT之後，可以寫成這樣</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">PointerFamily</span></span> &#123; <span class="class"><span class="keyword">type</span> <span class="title">Pointer</span></span>&lt;T&gt;; &#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RcFamily</span></span>;  <span class="comment">// Just a marker type; could also use e.g. an empty enum </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArcFamily</span></span>; <span class="comment">// Just a marker type; could also use e.g. an empty enum </span></span><br><span class="line"><span class="keyword">impl</span> PointerFamily <span class="keyword">for</span> RcFamily &#123; <span class="class"><span class="keyword">type</span> <span class="title">Pointer</span></span>&lt;T&gt; = Rc&lt;T&gt;; &#125;</span><br><span class="line"><span class="keyword">impl</span> PointerFamily <span class="keyword">for</span> ArcFamily &#123; <span class="class"><span class="keyword">type</span> <span class="title">Pointer</span></span>&lt;T&gt; = Arc&lt;T&gt;; &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span></span>&lt;P: PointerFamily&gt; &#123; bar: P::Pointer&lt;<span class="built_in">String</span>&gt;, &#125;</span><br></pre></td></tr></table></figure>
<h3 id="C-Solution"><a href="#C-Solution" class="headerlink" title="C++ Solution"></a>C++ Solution</h3><p>不過用C++對我來說反而更好理解，就是用nested template來做<br>首先是等價的版本</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rc</span> &#123;</span>&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Arc</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RcFamily</span> &#123;</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">using</span> type = Rc&lt;T&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ArcFamily</span> &#123;</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">using</span> type = Arc&lt;T&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">PointerFamily</span> &#123;</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="keyword">using</span> type = T::<span class="keyword">template</span> type&lt;U&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    <span class="keyword">typename</span> PointerFamily&lt;T&gt;::<span class="keyword">template</span> type&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; bar;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>不過對於這問題，還有更簡單的方法<br>用template template parameter即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rc</span> &#123;</span>&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Arc</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">    T&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt; bar;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="More-complicated-example"><a href="#More-complicated-example" class="headerlink" title="More complicated example"></a>More complicated example</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Mappable</span></span> &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Item</span></span>;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Result</span></span>&lt;U&gt;;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">map</span></span>&lt;U, P: <span class="built_in">FnMut</span>(Self::Item) -&gt; U&gt;(<span class="keyword">self</span>, f: P) -&gt; Self::<span class="built_in">Result</span>&lt;U&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T&gt; Mappable <span class="keyword">for</span> <span class="built_in">Option</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Item</span></span> = T;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Result</span></span>&lt;U&gt; = <span class="built_in">Option</span>&lt;U&gt;;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">map</span></span>&lt;U, P: <span class="built_in">FnMut</span>(Self::Item) -&gt; U&gt;(<span class="keyword">self</span>, f: P) -&gt; <span class="built_in">Option</span>&lt;U&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.map(f)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span>&lt;T, E&gt; Mappable <span class="keyword">for</span> <span class="built_in">Result</span>&lt;T, E&gt; &#123;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Item</span></span> = T;</span><br><span class="line">    <span class="class"><span class="keyword">type</span> <span class="title">Result</span></span>&lt;U&gt; = <span class="built_in">Result</span>&lt;U, E&gt;;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">map</span></span>&lt;U, P: <span class="built_in">FnMut</span>(Self::Item) -&gt; U&gt;(<span class="keyword">self</span>, f: P) -&gt; <span class="built_in">Result</span>&lt;U, E&gt; &#123;</span><br><span class="line">        <span class="keyword">self</span>.map(f)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等價的C++版本大概是</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">Option</span> &#123;</span></span><br><span class="line">    <span class="comment">// Option implementation...</span></span><br><span class="line">    <span class="comment">// The "GAT":</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">U</span>&gt;</span></span><br><span class="line"><span class="class">    <span class="title">using</span> <span class="title">MapResult</span> = <span class="title">Option</span>&lt;U&gt;;</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">U</span>, <span class="title">class</span> <span class="title">F</span>&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    <span class="title">Option</span>&lt;U&gt; <span class="title">map</span>(<span class="title">F</span> <span class="title">f</span>) &#123;</span></span><br><span class="line">        <span class="comment">// Apply f to the contents of `this`</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">concept</span> <span class="title">Mappable</span> = <span class="title">requires</span> &#123;</span></span><br><span class="line">    <span class="keyword">typename</span> T::<span class="keyword">template</span> MapResult&lt;<span class="keyword">int</span>&gt;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;Mappable T&gt;</span><br><span class="line"><span class="function"><span class="keyword">typename</span> T::<span class="keyword">template</span> MapResult&lt;<span class="keyword">int</span>&gt; <span class="title">zero_to_42</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.<span class="keyword">template</span> <span class="built_in">map</span>&lt;<span class="keyword">int</span>&gt;([](<span class="keyword">int</span> x) &#123;</span><br><span class="line">        <span class="keyword">return</span> x == <span class="number">0</span> ? <span class="number">42</span> : <span class="number">0</span> ;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/12/24/C-resource-managment-defer-unique-ptr-out-ptr-template-auto-and-coroutine/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="HungMingWu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="第十三號艦隊">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/12/24/C-resource-managment-defer-unique-ptr-out-ptr-template-auto-and-coroutine/" class="post-title-link" itemprop="url">C resource managment, defer, unique_ptr, out_ptr, template auto and coroutine</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-12-24 14:16:21" itemprop="dateCreated datePublished" datetime="2022-12-24T14:16:21+00:00">2022-12-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-10-06 01:47:17" itemprop="dateModified" datetime="2025-10-06T01:47:17+00:00">2025-10-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>這裡的Resouce不光指Memory，可能是FILE，或是ffmpeg那種Handle<br>Resource Management一直都是個討論的重點，要混合在C++使用，有很多種方法<br>拿FILE來舉例好了</p>
<h3 id="什麼都不做"><a href="#什麼都不做" class="headerlink" title="什麼都不做"></a>什麼都不做</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FILE *fp = fopen(...);</span><br><span class="line"><span class="comment">// Do somthing</span></span><br><span class="line">fclose(fp);</span><br></pre></td></tr></table></figure>
<p>這種方法最直接，不用學其他額外的方法，不過常常會因為程式碼的改變，而忘記release  resource這件事，因此才有其他流派生存的機會</p>
<h3 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h3><p>大概的程式碼長這樣，不過在C++不一定叫defer，可能叫ScopeGuard之類的東西，不過原理是一樣的</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">FILE *fp = fopen(...);</span><br><span class="line">defer([&amp;]() &#123; fclose(fp); &#125;);</span><br></pre></td></tr></table></figure>
<p>在小規模的使用是沒問題的，當Resoruce 一多就會變得冗餘，例如</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FILE *fp1 = fopen(...);</span><br><span class="line">defer([&amp;]() &#123; fclose(fp1); &#125;);</span><br><span class="line">FILE *fp2 = fopen(...);</span><br><span class="line">defer([&amp;]() &#123; fclose(fp2); &#125;);</span><br><span class="line">FILE *fp3 = fopen(...);</span><br><span class="line">defer([&amp;]() &#123; fclose(fp3); &#125;);</span><br></pre></td></tr></table></figure>
<p>於是C++ RAII的方式出現了，有鑑於<code>shared_ptr</code>耗費較多的資源，這邊的方案都是<code>unique_ptr</code>為主</p>
<h3 id="naive-unique-ptr-solution"><a href="#naive-unique-ptr-solution" class="headerlink" title="naive unique_ptr solution"></a>naive unique_ptr solution</h3><p>為每個resource寫出一個Wrapper</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FILEWrapper</span> &#123;</span></span><br><span class="line">	FILE* f;</span><br><span class="line">	FILEWrapper(FILE *file) : f(file) &#123;&#125;</span><br><span class="line">	~FILEWrapper() &#123; <span class="keyword">if</span> (f) fclose(f); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;FILEWrapper&gt; fp;</span><br></pre></td></tr></table></figure>
<p>沒什麼不好，只是工作量太大，每加一種Resource就要有個Wrapper，那有沒有其他方案</p>
<h3 id="unique-ptr-with-custrom-destruction"><a href="#unique-ptr-with-custrom-destruction" class="headerlink" title="unique_ptr with custrom destruction"></a>unique_ptr with custrom destruction</h3><p>同樣以FILE舉例，新增一個function object</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FileCloser</span> &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(FILE *f)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (f) fclose(f);</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;FILE, FileCloser&gt; fp;</span><br></pre></td></tr></table></figure>
<p>這樣看起來跟上面差不了多少<br>另一種方法是</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::unique_ptr&lt;FILE, int(*)(FILE *)&gt; fp(fp, fclose);</span><br></pre></td></tr></table></figure>
<p>這種方式比上面那個還差</p>
<h4 id="out-ptr"><a href="#out-ptr" class="headerlink" title="out_ptr"></a>out_ptr</h4><p>雖然跟上面無關，不過這也是unique_ptr的一部分，一併提出<br>由於API設計的關係，input需要的是double pointer<br>程式有些可能會變成這樣</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ITEMIDLIST_ABSOLUTE, CoTaskMemFreeDeleter&gt; pidl; ITEMIDLIST_ABSOLUTE* rawPidl;</span><br><span class="line">hr = SHGetIDListFromObject(item, &amp;rawPidl);</span><br><span class="line">pidl.reset(rawPidl); </span><br><span class="line"><span class="keyword">if</span> (FAILED(hr)) </span><br><span class="line">	<span class="keyword">return</span> hr;</span><br></pre></td></tr></table></figure>
<p>這時候就是out_ptr使用場警</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ITEMIDLIST_ABSOLUTE, CoTaskMemFreeDeleter&gt; pidl;</span><br><span class="line">hr = SHGetIDListFromObject(item, <span class="built_in">std</span>::out_ptr(pidl));</span><br><span class="line"><span class="keyword">if</span> (FAILED(hr)) </span><br><span class="line">	<span class="keyword">return</span> hr;</span><br></pre></td></tr></table></figure>
<p>雖然這是在C++23才進入標準庫，不過<br><a href="https://github.com/soasis/out_ptr" target="_blank" rel="noopener">GitHub - soasis/out_ptr: Repository for a C++11 implementation of std::out_ptr (p1132), as a standalone library!</a><br>已經可以先嘗鮮了</p>
<h3 id="template-auto"><a href="#template-auto" class="headerlink" title="template auto"></a>template auto</h3><p>C++17之後，放寬template的要求<br>於是這樣的程式碼成為可能</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> destroy&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">c_resource</span> &#123;</span></span><br><span class="line">&#125;;</span><br><span class="line">c_resource&lt;fclose&gt; fp;</span><br></pre></td></tr></table></figure>
<p>配合上C++20的Concept之後，成為威力強大的武器<br>以下是從Meeting CPP 2022中節錄出來的片段</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">auto</span> * ConstructFunction, <span class="keyword">auto</span> * DestructFunction&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">c_resource</span> &#123;</span></span><br><span class="line">	<span class="keyword">using</span> pointer       = T *;</span><br><span class="line">	<span class="keyword">using</span> const_pointer = <span class="built_in">std</span>::<span class="keyword">add_const_t</span>&lt;T&gt; *;</span><br><span class="line">	<span class="keyword">using</span> element_type  = T;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">using</span> Constructor = <span class="keyword">decltype</span>(ConstructFunction);</span><br><span class="line">	<span class="keyword">using</span> Destructor  = <span class="keyword">decltype</span>(DestructFunction);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static_assert</span>(<span class="built_in">std</span>::is_function_v&lt;<span class="built_in">std</span>::<span class="keyword">remove_pointer_t</span>&lt;Constructor&gt;&gt;,</span><br><span class="line">	              <span class="string">"I need a C function"</span>);</span><br><span class="line">	<span class="keyword">static_assert</span>(<span class="built_in">std</span>::is_function_v&lt;<span class="built_in">std</span>::<span class="keyword">remove_pointer_t</span>&lt;Destructor&gt;&gt;,</span><br><span class="line">	              <span class="string">"I need a C function"</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">constexpr</span> Constructor construct = ConstructFunction;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">constexpr</span> Destructor destruct   = DestructFunction;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">constexpr</span> T * null              = c_resource_null_value&lt;T&gt;;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">construct_t</span> &#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">construct_t</span> constructed = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">	[[nodiscard]] <span class="function"><span class="keyword">constexpr</span> <span class="title">c_resource</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>= <span class="keyword">default</span>;</span><br><span class="line">	[[nodiscard]] <span class="function"><span class="keyword">constexpr</span> <span class="keyword">explicit</span> <span class="title">c_resource</span><span class="params">(<span class="keyword">construct_t</span>)</span> <span class="keyword">noexcept</span></span></span><br><span class="line">	    requires std::is_invocable_r_v&lt;T *, Constructor&gt;</span><br><span class="line">	: ptr_&#123; construct() &#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line">	    <span class="keyword">requires</span>(<span class="keyword">sizeof</span>...(Ts) &gt; <span class="number">0</span> &amp;&amp; <span class="built_in">std</span>::is_invocable_r_v&lt;T *, Constructor, Ts...&gt;)</span><br><span class="line">	[[nodiscard]] <span class="function"><span class="keyword">constexpr</span> <span class="title">explicit</span><span class="params">(<span class="keyword">sizeof</span>...(Ts) == <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">	    <span class="title">c_resource</span><span class="params">(Ts &amp;&amp;... Args)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">	: ptr_</span>&#123; construct(<span class="keyword">static_cast</span>&lt;Ts &amp;&amp;&gt;(Args)...) &#125; &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line">	    <span class="keyword">requires</span>(<span class="keyword">sizeof</span>...(Ts) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">	             <span class="keyword">requires</span>(T * p, Ts... Args) &#123;</span><br><span class="line">		             &#123; construct(&amp;p, Args...) &#125; -&gt; <span class="built_in">std</span>::same_as&lt;<span class="keyword">void</span>&gt;;</span><br><span class="line">	             &#125;)</span><br><span class="line">	[[nodiscard]] <span class="function"><span class="keyword">constexpr</span> <span class="title">explicit</span><span class="params">(<span class="keyword">sizeof</span>...(Ts) == <span class="number">1</span>)</span></span></span><br><span class="line"><span class="function">	    <span class="title">c_resource</span><span class="params">(Ts &amp;&amp;... Args)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">	: ptr_</span>&#123; null &#125; &#123;</span><br><span class="line">		construct(&amp;ptr_, <span class="keyword">static_cast</span>&lt;Ts &amp;&amp;&gt;(Args)...);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line">	    <span class="keyword">requires</span>(<span class="built_in">std</span>::is_invocable_v&lt;Constructor, T **, Ts...&gt;)</span><br><span class="line">	[[nodiscard]] <span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">emplace</span><span class="params">(Ts &amp;&amp;... Args)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">		_destruct(ptr_);</span><br><span class="line">		ptr_ = null;</span><br><span class="line">		<span class="keyword">return</span> construct(&amp;ptr_, <span class="keyword">static_cast</span>&lt;Ts &amp;&amp;&gt;(Args)...);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	[[nodiscard]] <span class="function"><span class="keyword">constexpr</span> <span class="title">c_resource</span><span class="params">(c_resource &amp;&amp; other)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">		ptr_       = other.ptr_;</span><br><span class="line">		other.ptr_ = null;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="keyword">constexpr</span> c_resource &amp; <span class="keyword">operator</span>=(c_resource &amp;&amp; rhs) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="keyword">this</span> != &amp;rhs) &#123;</span><br><span class="line">			_destruct(ptr_);</span><br><span class="line">			ptr_     = rhs.ptr_;</span><br><span class="line">			rhs.ptr_ = null;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;;</span><br><span class="line">	<span class="function"><span class="keyword">constexpr</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(c_resource &amp; other)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">		<span class="keyword">auto</span> ptr   = ptr_;</span><br><span class="line">		ptr_       = other.ptr_;</span><br><span class="line">		other.ptr_ = ptr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> destructible =</span><br><span class="line">	    <span class="built_in">std</span>::is_invocable_v&lt;Destructor, T *&gt; || <span class="built_in">std</span>::is_invocable_v&lt;Destructor, T **&gt;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">constexpr</span> ~c_resource() <span class="keyword">noexcept</span> = <span class="keyword">delete</span>;</span><br><span class="line">	<span class="keyword">constexpr</span> ~c_resource() <span class="keyword">noexcept</span></span><br><span class="line">	    <span class="keyword">requires</span> destructible</span><br><span class="line">	&#123;</span><br><span class="line">		_destruct(ptr_);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">constexpr</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">	    <span class="keyword">requires</span> destructible</span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		_destruct(ptr_);</span><br><span class="line">		ptr_ = null;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">constexpr</span> c_resource &amp; <span class="keyword">operator</span>=(<span class="built_in">std</span>::<span class="keyword">nullptr_t</span>) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">		clear();</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	[[nodiscard]] <span class="function"><span class="keyword">constexpr</span> <span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">bool</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> ptr_ != null;</span><br><span class="line">	&#125;</span><br><span class="line">	[[nodiscard]] <span class="function"><span class="keyword">constexpr</span> <span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> ptr_ == null; &#125;</span><br><span class="line">	[[nodiscard]] <span class="function"><span class="keyword">constexpr</span> <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="title">have</span><span class="params">(<span class="keyword">const</span> c_resource &amp; r)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> r.ptr_ != null;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> <span class="keyword">operator</span>&lt;=&gt;(<span class="keyword">const</span> c_resource &amp;) = <span class="keyword">delete</span>;</span><br><span class="line">	[[nodiscard]] <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> c_resource &amp; rhs) <span class="keyword">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span> == <span class="built_in">std</span>::<span class="built_in">memcmp</span>(ptr_, rhs.ptr_, <span class="keyword">sizeof</span>(T));</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(__cpp_explicit_this_parameter)</span></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> V&gt;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> less_const = <span class="built_in">std</span>::is_const_v&lt;U&gt; &lt; <span class="built_in">std</span>::is_const_v&lt;V&gt;;</span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> V&gt;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">bool</span> similar = <span class="built_in">std</span>::is_same_v&lt;<span class="built_in">std</span>::<span class="keyword">remove_const_t</span>&lt;U&gt;, T&gt;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> Self&gt;</span><br><span class="line">	    <span class="keyword">requires</span>(similar&lt;U, T&gt; &amp;&amp; !less_const&lt;U, Self&gt;)</span><br><span class="line">	[[nodiscard]] <span class="keyword">constexpr</span> <span class="keyword">operator</span> U *(<span class="keyword">this</span> Self &amp;&amp; self) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">std</span>::forward_like&lt;Self&gt;(self.ptr_);</span><br><span class="line">	&#125;</span><br><span class="line">	[[nodiscard]] <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="keyword">operator</span>-&gt;(<span class="keyword">this</span> <span class="keyword">auto</span> &amp;&amp; self) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">std</span>::forward_like&lt;<span class="keyword">decltype</span>(self)&gt;(self.ptr_);</span><br><span class="line">	&#125;</span><br><span class="line">	[[nodiscard]] <span class="function"><span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">get</span><span class="params">(<span class="keyword">this</span> <span class="keyword">auto</span> &amp;&amp; self)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">std</span>::forward_like&lt;<span class="keyword">decltype</span>(self)&gt;(self.ptr_);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">	[[nodiscard]] <span class="function"><span class="keyword">constexpr</span> <span class="keyword">operator</span> <span class="title">pointer</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> like(*<span class="keyword">this</span>); &#125;</span><br><span class="line">	[[nodiscard]] <span class="function"><span class="keyword">constexpr</span> <span class="keyword">operator</span> <span class="title">const_pointer</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> like(*<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	[[nodiscard]] <span class="keyword">constexpr</span> pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">noexcept</span> &#123; <span class="keyword">return</span> like(*<span class="keyword">this</span>); &#125;</span><br><span class="line">	[[nodiscard]] <span class="keyword">constexpr</span> const_pointer <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span> <span class="keyword">noexcept</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> like(*<span class="keyword">this</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	[[nodiscard]] <span class="function"><span class="keyword">constexpr</span> pointer <span class="title">get</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> like(*<span class="keyword">this</span>); &#125;</span><br><span class="line">	[[nodiscard]] <span class="function"><span class="keyword">constexpr</span> const_pointer <span class="title">get</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> like(*<span class="keyword">this</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">like</span><span class="params">(c_resource &amp; self)</span> <span class="keyword">noexcept</span> </span>&#123; <span class="keyword">return</span> self.ptr_; &#125;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">auto</span> <span class="title">like</span><span class="params">(<span class="keyword">const</span> c_resource &amp; self)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;const_pointer&gt;(self.ptr_);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">constexpr</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">(pointer ptr = null)</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">		_destruct(ptr_);</span><br><span class="line">		ptr_ = ptr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">constexpr</span> pointer <span class="title">release</span><span class="params">()</span> <span class="keyword">noexcept</span> </span>&#123;</span><br><span class="line">		<span class="keyword">auto</span> ptr = ptr_;</span><br><span class="line">		ptr_     = null;</span><br><span class="line">		<span class="keyword">return</span> ptr;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">template</span> &lt;<span class="keyword">auto</span> * CleanupFunction&gt;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">guard</span> &#123;</span></span><br><span class="line">		<span class="keyword">using</span> cleaner = <span class="keyword">decltype</span>(CleanupFunction);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">static_assert</span>(<span class="built_in">std</span>::is_function_v&lt;<span class="built_in">std</span>::<span class="keyword">remove_pointer_t</span>&lt;cleaner&gt;&gt;,</span><br><span class="line">		              <span class="string">"I need a C function"</span>);</span><br><span class="line">		<span class="keyword">static_assert</span>(<span class="built_in">std</span>::is_invocable_v&lt;cleaner, pointer&gt;, <span class="string">"Please check the function"</span>);</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">constexpr</span> <span class="title">guard</span><span class="params">(c_resource &amp; Obj)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">		: ptr_</span>&#123; Obj.ptr_ &#125; &#123;&#125;</span><br><span class="line">		<span class="keyword">constexpr</span> ~guard() <span class="keyword">noexcept</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (ptr_ != null)</span><br><span class="line">				CleanupFunction(ptr_);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		pointer ptr_;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">void</span> _destruct(pointer &amp; p) <span class="keyword">noexcept</span></span><br><span class="line">	    <span class="keyword">requires</span> <span class="built_in">std</span>::is_invocable_v&lt;Destructor, T *&gt;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (p != null)</span><br><span class="line">			destruct(p);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">constexpr</span> <span class="keyword">static</span> <span class="keyword">void</span> _destruct(pointer &amp; p) <span class="keyword">noexcept</span></span><br><span class="line">	    <span class="keyword">requires</span> <span class="built_in">std</span>::is_invocable_v&lt;Destructor, T **&gt;</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (p != null)</span><br><span class="line">			destruct(&amp;p);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pointer ptr_ = null;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>幾乎修正了上面所說的痛點<br>使用上也只要</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c_resource&lt;FILE, fopen, fclose&gt; fp;</span><br></pre></td></tr></table></figure>
<p>算是目前看到最通用的解法</p>
<h3 id="Coroutine-solution"><a href="#Coroutine-solution" class="headerlink" title="Coroutine solution"></a>Coroutine solution</h3><p>這算是另闢新徑的方案，RAII的方案都把release resource放在destructor中<br>自從C++20引進Corotuine，產生了新的可能<br>使用上大概會是這樣</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">co_resource&lt;FILE*&gt; <span class="title">usage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  FILE *fp = fopen(...);</span><br><span class="line">  <span class="keyword">co_yield</span> fp;</span><br><span class="line">  fclose(fp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  co_resource&lt;FILE*&gt; r = usage();</span><br><span class="line">  <span class="comment">// Do somthing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li><a href="https://www.sandordargo.com/blog/2022/12/07/inout_ptr-and-out_ptr" target="_blank" rel="noopener">C++23: std::out_ptr and std::inout_ptr</a></li>
<li><a href="https://zh-blog.logan.tw/2020/07/12/cxx-17-template-auto-non-type-template-parameter-type-deduction/" target="_blank" rel="noopener">C++ 17 非型別樣版參數型別推導</a></li>
<li><a href="https://vector-of-bool.github.io/2021/12/30/co_resource.html" target="_blank" rel="noopener">co_resource: An RAII coroutine (vector-of-bool.github.io)</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/11/06/Allocator-in-C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="HungMingWu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="第十三號艦隊">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/11/06/Allocator-in-C/" class="post-title-link" itemprop="url">Allocator in C++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-11-06 15:46:46" itemprop="dateCreated datePublished" datetime="2022-11-06T15:46:46+00:00">2022-11-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-10-06 01:47:17" itemprop="dateModified" datetime="2025-10-06T01:47:17+00:00">2025-10-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Allocator-for-C-11"><a href="#Allocator-for-C-11" class="headerlink" title="Allocator for C++11"></a>Allocator for C++11</h3><p>滿足C++11中對Alloocator的需求，所能寫出的最簡單allocator<br>注意</p>
<ul>
<li>這邊的allocatte和deallocate不會呼叫Constructor/Destructor，只是單純的記憶體分配，為了簡單，直接用malloc/free</li>
<li>可以對兩個Allocator做比較的動作，如果兩者相等的話，可以達成在A進行allocate，而在B進行deallocate的動作</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Minallocator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">using</span> value_type = T;</span><br><span class="line"></span><br><span class="line">  <span class="function">T* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> num)</span> </span>&#123; <span class="keyword">return</span> allocate(num, <span class="literal">nullptr</span>); &#125;</span><br><span class="line">  <span class="function">T* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> num, <span class="keyword">const</span> <span class="keyword">void</span>* hint)</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">reinterpret_cast</span>&lt;T*&gt;(<span class="built_in">std</span>::<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(T) * num)); &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(T* ptr, <span class="keyword">size_t</span> num)</span> </span>&#123; <span class="built_in">std</span>::<span class="built_in">free</span>(ptr); &#125;</span><br><span class="line">  Minallocator() = <span class="keyword">default</span>;</span><br><span class="line">  ~Minallocator() = <span class="keyword">default</span>;</span><br><span class="line">  Minallocator(<span class="keyword">const</span> Minallocator&amp;)            = <span class="keyword">default</span>;</span><br><span class="line">  Minallocator(Minallocator&amp;&amp;)                 = <span class="keyword">default</span>;</span><br><span class="line">  Minallocator&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Minallocator&amp;) = <span class="keyword">default</span>;</span><br><span class="line">  Minallocator&amp; <span class="keyword">operator</span>=(Minallocator&amp;&amp;)      = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Minallocator&lt;T1&gt;&amp; lhs,<span class="keyword">const</span> Minallocator&lt;T2&gt;&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Minallocator&lt;T1&gt;&amp; lhs, <span class="keyword">const</span> Minallocator&lt;T2&gt;&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而要用自己的Allocate就可以這麼做</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>, Minallocator&lt;<span class="keyword">int</span>&gt;&gt; v;</span><br></pre></td></tr></table></figure>
<h3 id="std-scoped-allocator-adaptor"><a href="#std-scoped-allocator-adaptor" class="headerlink" title="std::scoped_allocator_adaptor"></a>std::scoped_allocator_adaptor</h3><p>不常用，有用到再說</p>
<h3 id="rebind"><a href="#rebind" class="headerlink" title="rebind"></a>rebind</h3><p>已知<code>T</code>類型的Allocator，想要根據相同策略拿到<code>U</code>類型的Allocator<br>也就是說希望用同樣的方式來分配<code>U</code><br>可以透過</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">allocator&lt;U&gt;=allocator&lt;T&gt;::rebind&lt;U&gt;::other.</span><br></pre></td></tr></table></figure>
<p>拿到，因此</p>
<p><code>std::allcoator&lt;T&gt;::rebind&lt;U&gt;::other</code>等同於<code>std::allcoator&lt;U&gt;</code><br><code>Myallcoator&lt;T&gt;::rebind&lt;U&gt;::other</code>等同於<code>Myallcoator&lt;U&gt;</code></p>
<p>在libstdc++中的實現</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> _Tp1&gt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rebind</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">      <span class="keyword">typedef</span> allocator&lt;_Tp1&gt; other;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>

<h3 id="Problem-with-allocators-and-containers"><a href="#Problem-with-allocators-and-containers" class="headerlink" title="Problem with allocators and containers"></a>Problem with allocators and containers</h3><p>這樣的程式碼會有問題</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ector&lt;<span class="keyword">int</span>, Minallocator&lt;<span class="keyword">int</span>&gt;&gt;  pool_vec  &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>, Other_allocator&lt;<span class="keyword">int</span>&gt;&gt; other_vec &#123; &#125;;</span><br><span class="line"></span><br><span class="line">other_vec = pool_vec;    <span class="comment">// ERROR!</span></span><br></pre></td></tr></table></figure>
<p>因為兩者的Allocator Type不同，所以直接複製不行，所以只要兩者相同就行了，也就是C++17 PMR的初衷</p>
<h3 id="C-17-Polymorphic-Memory-Resource"><a href="#C-17-Polymorphic-Memory-Resource" class="headerlink" title="C++17 Polymorphic Memory Resource"></a>C++17 Polymorphic Memory Resource</h3><p>新提出來的<code>memory_resource</code>是個asbtract class，不同的instance會有不同的行為<br>因此可以可以這樣做</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// define allocation behaviour via a custom "memory_resource"</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">my_memory_resource</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::pmr::memory_resource &#123; ... &#125;;</span><br><span class="line">my_memory_resource mem_res;</span><br><span class="line"><span class="keyword">auto</span> my_vector = <span class="built_in">std</span>::pmr::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">0</span>, &amp;mem_res);</span><br><span class="line"></span><br><span class="line"><span class="comment">// define a second memory resource</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">other_memory_resource</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::pmr::memory_resource &#123; ... &#125;;</span><br><span class="line">other_memory_resource mem_res_other;</span><br><span class="line"><span class="keyword">auto</span> my_other_vector = <span class="built_in">std</span>::pmr::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">0</span>, &amp;mes_res_other);</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> vec = my_vector; <span class="comment">// type is std::pmr::vector&lt;int&gt;</span></span><br><span class="line">vec = my_other_vector; <span class="comment">// this is ok -</span></span><br><span class="line">      <span class="comment">// my_vector and my_other_vector have same type</span></span><br></pre></td></tr></table></figure>

<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li><a href="https://blog.feabhas.com/2019/03/thanks-for-the-memory-allocator/" target="_blank" rel="noopener">Thanks for the memory (allocator)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/96089089" target="_blank" rel="noopener">游戏引擎开发新感觉！(6) c++17内存管理</a></li>
<li><a href="https://stackoverflow.com/questions/38010544/polymorphic-allocator-when-and-why-should-i-use-it" target="_blank" rel="noopener">polymorphic_allocator: when and why should I use it?</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/10/15/Reflection-in-C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="HungMingWu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="第十三號艦隊">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/10/15/Reflection-in-C/" class="post-title-link" itemprop="url">Reflection in C++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-10-15 19:27:39" itemprop="dateCreated datePublished" datetime="2022-10-15T19:27:39+00:00">2022-10-15</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-10-06 01:47:17" itemprop="dateModified" datetime="2025-10-06T01:47:17+00:00">2025-10-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Test</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> index;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">printInfo</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"index: "</span> &lt;&lt; index &lt;&lt; <span class="string">", name: "</span> &lt;&lt; name &lt;&lt; <span class="string">"\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        Test test;</span><br><span class="line">        test.index = <span class="number">1</span>;</span><br><span class="line">        test.name = <span class="string">"test_1"</span>;</span><br><span class="line">        test.printInfo();</span><br><span class="line">        <span class="keyword">auto</span> index_addr = &amp;Test::index;</span><br><span class="line">        <span class="keyword">auto</span> name_addr = &amp;Test::name;</span><br><span class="line">        <span class="keyword">auto</span> fun_print_addr = &amp;Test::printInfo;</span><br><span class="line">        test.*index_addr = <span class="number">2</span>;</span><br><span class="line">        test.*name_addr = <span class="string">"test_2"</span>;</span><br><span class="line">        (test.*fun_print_addr)();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>透過上面的<code>index_addr</code>，<code>name_addr</code>，<code>fun_print_addr</code>等，可以對object進行操作<br>而反射主要分成兩部分</p>
<ul>
<li>Metadata generation<br>和C++ object有關的information就叫做metadata，如上面的例子，這邊的困難點是如何減少工作量</li>
<li>Metadata Reflection<br>既然有了Metadata，如何跟現實使用上連結起來</li>
</ul>
<p>雖然目前的官方標準還沒出來，不過現在有兩大流派</p>
<h3 id="手工打造"><a href="#手工打造" class="headerlink" title="手工打造"></a>手工打造</h3><p>什麼辦不到的事情，用Marco就好了<br>以Boost Describe舉例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> m1;</span><br><span class="line">    <span class="keyword">int</span> m2;</span><br><span class="line">&#125;;</span><br><span class="line">BOOST_DESCRIBE_STRUCT(X, (), (m1, m2))</span><br></pre></td></tr></table></figure>
<p>其他Macro Based的方案也差不多，就是另外定義一個Macro，自動生成類似上面的Metadata<br>不過這邊的問題就是</p>
<ul>
<li>你要同時維護兩份資料的一致性</li>
<li>Macro滿天飛</li>
<li>修改困難 (因為都是Marco的黑魔法，要新增功能就得對Marco動刀)</li>
</ul>
<h3 id="libclang"><a href="#libclang" class="headerlink" title="libclang"></a>libclang</h3><p>另外一派就是借助libclang來動手生成，透過Parse C++ AST來生成需要的API<br>舉例說明</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> field = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> static_field;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">static_method</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>生成的Metadata可以這麼使用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">reflang::Class&lt;MyClass&gt; metadata;</span><br><span class="line">MyClass c;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Modify / use c's 'field'.</span></span><br><span class="line">reflang::Reference ref = metadata.GetField(c, <span class="string">"field"</span>);</span><br><span class="line">ref.GetT&lt;<span class="keyword">int</span>&gt;() = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Modify / use 'static_field'.</span></span><br><span class="line">ref = metadata.GetStaticField(<span class="string">"static_field"</span>)</span><br><span class="line">ref.GetT&lt;<span class="keyword">int</span>&gt;() = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Execute 'method()'.</span></span><br><span class="line"><span class="keyword">auto</span> methods = metadata.GetMethod(<span class="string">"method"</span>);</span><br><span class="line">(*methods[<span class="number">0</span>])(c);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Execute 'static_method()'.</span></span><br><span class="line"><span class="keyword">auto</span> methods = metadata.GetStaticMethod(<span class="string">"static_method"</span>);</span><br><span class="line">(*methods[<span class="number">0</span>])();</span><br></pre></td></tr></table></figure>
<p>這個方案的問題在於</p>
<ul>
<li>要有libclang才能用</li>
<li>構建的時候會多一個步驟，必須掃描所有的檔案，生成需要的header/sources，修改Makefile/CMakeLists.txt來調整編譯流程</li>
</ul>
<h3 id="Reflection-API-in-the-future"><a href="#Reflection-API-in-the-future" class="headerlink" title="Reflection API in the future"></a>Reflection API in the future</h3><p>雖然現有的Reflection library多的跟山一樣，不過眾口難調，有些是針對特定用途設計的，無法涵蓋其他方面的使用，有些功能完整，但是難用<br>於是乎就有人想要對語法方面下手，成為C++ Standard中的一部分</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">void</span> <span class="title">print_type</span>() &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"void "</span></span><br><span class="line">              &lt;&lt; get_name_v&lt;reflexpr(print_type&lt;T&gt;)&gt; <span class="comment">// guaranteed "print_type"</span></span><br><span class="line">              &lt;&lt; <span class="string">"() [with T = "</span></span><br><span class="line">              &lt;&lt; get_display_name_v&lt;reflexpr(T)&gt; </span><br><span class="line">              &lt;&lt; <span class="string">"]"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>reflexpr和decltype一樣是type-based，所以可以套用到type based metaprogramming中<br>不過會不會成為標準是另外一回事了<br>跟Network Library一樣，成為標準之前先用成熟的方案解決</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li><a href="https://zhuanlan.zhihu.com/p/88144082" target="_blank" rel="noopener">现代 C++ 编译时 结构体字段反射</a></li>
<li><a href="https://www.boost.org/doc/libs/master/libs/describe/doc/html/describe.html" target="_blank" rel="noopener">Boost Describe</a></li>
<li><a href="https://github.com/chakaz/reflang" target="_blank" rel="noopener">Reflang - Modern C++ reflection using libclang</a></li>
<li><a href="https://en.cppreference.com/w/cpp/keyword/reflexpr" target="_blank" rel="noopener">C++ keywords: reflexpr (reflection TS) </a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/09/09/How-to-write-comparsion-operator-for-custom-type-in-C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="HungMingWu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="第十三號艦隊">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/09/09/How-to-write-comparsion-operator-for-custom-type-in-C/" class="post-title-link" itemprop="url">How to write comparsion operator for custom type in C++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-09-09 14:02:28" itemprop="dateCreated datePublished" datetime="2022-09-09T14:02:28+00:00">2022-09-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-10-06 01:47:17" itemprop="dateModified" datetime="2025-10-06T01:47:17+00:00">2025-10-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>How to write comparsion operator for custom type</p>
<h3 id="The-simple-case"><a href="#The-simple-case" class="headerlink" title="The simple case"></a>The simple case</h3><p>假設我們有一個類別</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Value</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>我們要怎麼寫出的程式碼</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Value v1, v2;</span><br><span class="line">v1 &lt; v2;</span><br></pre></td></tr></table></figure>
<p>有幾種方式</p>
<h3 id="Naive-solution"><a href="#Naive-solution" class="headerlink" title="Naive solution"></a>Naive solution</h3><p>一種是當member function存在<br>手動寫出所有comparsion operator</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Value</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Value &amp;rhs) &#123; <span class="keyword">return</span> v &lt; rhs.v; &#125;</span><br><span class="line">	<span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Value &amp;rhs) &#123; <span class="keyword">return</span> v == rhs.v; &#125;</span><br><span class="line">	<span class="comment">// Ignore</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>另外一種是Free function存在</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Value &amp;lhs, <span class="keyword">const</span> Value &amp;rhs) &#123; <span class="keyword">return</span> lhs.v &lt; rhs.v; &#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Value &amp;lhs, <span class="keyword">const</span> Value &amp;rhs) &#123; <span class="keyword">return</span> lhs.v == rhs.v; &#125;</span><br></pre></td></tr></table></figure>
<p>兩種實現原理相同，看情況選擇要用哪種，現在要討論的是其他的問題<br>當我們需要支持更多運算符號時，我們就需要寫更多的Function</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> Value &amp;lhs, <span class="keyword">const</span> Value &amp;rhs);</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Value &amp;lhs, <span class="keyword">const</span> Value &amp;rhs);</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Value &amp;lhs, <span class="keyword">const</span> Value &amp;rhs);</span><br></pre></td></tr></table></figure>
<p>如果我們需要支援另外一種Type</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Value1</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> v;</span><br><span class="line">	<span class="keyword">int</span> v1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然後又要出現一堆複製貼上加上手動修改的產物</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> Value1 &amp;lhs, <span class="keyword">const</span> Value1 &amp;rhs);</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>&gt;(<span class="keyword">const</span> Value1 &amp;lhs, <span class="keyword">const</span> Value1 &amp;rhs);</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Value1 &amp;lhs, <span class="keyword">const</span> Value1 &amp;rhs);</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>!=(<span class="keyword">const</span> Value1 &amp;lhs, <span class="keyword">const</span> Value1 &amp;rhs);</span><br></pre></td></tr></table></figure>
<p>寫起來麻煩又沒什麼技術含量</p>
<h3 id="CRTP-solution"><a href="#CRTP-solution" class="headerlink" title="CRTP solution"></a>CRTP solution</h3><p>有些operator可以用其他operator表示，例如Not Equal就是Not + Equal<br>所以我們可以用CRTP技巧減少我們的程式碼</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">Derived</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">struct</span> <span class="title">Equality</span> &#123;</span></span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> !=(<span class="keyword">const</span> Equality &amp;rhs) &#123;</span><br><span class="line">                <span class="keyword">return</span> !(<span class="keyword">static_cast</span>&lt;Derived&amp;&gt;(*<span class="keyword">this</span>) == <span class="keyword">static_cast</span>&lt;<span class="keyword">const</span> Derived&amp;&gt;(rhs));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Value</span> :</span> Equality&lt;Value&gt; &#123;</span><br><span class="line">        <span class="keyword">int</span> v;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Value &amp;rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> v == rhs.v; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Value1</span> :</span> Equality&lt;Value1&gt; &#123;</span><br><span class="line">		<span class="keyword">int</span> v;</span><br><span class="line">        <span class="keyword">int</span> v1;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Value1 &amp;rhs) <span class="keyword">const</span> &#123; <span class="keyword">return</span> v == rhs.v; &amp;&amp; v1 == rhs.v1; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其他的operator可以如法炮製，很多的C++ Graphics/Math Library都用了這個技巧<br>只要實作<code>&lt;</code>和<code>==</code>，可以用來推導出其他四種比較關係<br>不過很不直觀，CRTP就是一種Hack，那有沒有更好的方法</p>
<h3 id="C-20-spaceship-operator"><a href="#C-20-spaceship-operator" class="headerlink" title="C++20 spaceship  operator"></a>C++20 spaceship  operator</h3><p>Spaceship oerator也叫做The Three-Way Comparison Operator<br>這是C++20的一個特性，直接上Code來說明</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;compare&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Value</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> v;</span><br><span class="line">        <span class="keyword">auto</span> <span class="keyword">operator</span>&lt;=&gt;(<span class="keyword">const</span> Value&amp;) <span class="keyword">const</span> = <span class="keyword">default</span>; (<span class="number">1</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>而Compiler直接為你生成Comparsion Code，原先的程式碼視為這樣</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(a &lt;=&gt; b) &lt; <span class="number">0</span>  <span class="comment">//true if a &lt; b</span></span><br><span class="line">(a &lt;=&gt; b) &gt; <span class="number">0</span>  <span class="comment">//true if a &gt; b</span></span><br><span class="line">(a &lt;=&gt; b) == <span class="number">0</span> <span class="comment">//true if a is equal/equivalent to b</span></span><br></pre></td></tr></table></figure>
<p>這種方式類似於<code>strcmp</code>，會回傳<code>&lt;0</code>，<code>&gt;0</code>，<code>0</code>三種情形<br>基本上這樣就滿足了80%的需求了，不過人生最難的就是那個But<br>有需要的話自定義比較方式的話，可以自定義comparsion operator</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Value1</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> v;</span><br><span class="line">	<span class="keyword">int</span> v1;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">auto</span> <span class="keyword">operator</span>&lt;=&gt;(<span class="keyword">const</span> Value1&amp; rhs) <span class="keyword">const</span> &#123;</span><br><span class="line">	   <span class="keyword">if</span> (<span class="keyword">auto</span> cmp = v &lt;=&gt; rhs.v; cmp != <span class="number">0</span>)</span><br><span class="line">		   <span class="keyword">return</span> cmp;</span><br><span class="line">		<span class="keyword">return</span> v1 &lt;=&gt; rhs.v1;</span><br><span class="line">	&#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>不過現在spaceship operator必須回傳的是<code>std::strong_ordering</code>，<code>std::weak_ordering</code>，<code>std::partial_ordering</code>其中之一<br>至於三種ordering的差異，在此不探討，需要的話去Reference看，大部分只需要<code>std::strong_ordering</code>即能完成需求</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ul>
<li><a href="https://blog.tartanllama.xyz/spaceship-operator/" target="_blank" rel="noopener">Spaceship Operator</a></li>
<li><a href="https://www.modernescpp.com/index.php/c-20-the-three-way-comparison-operator" target="_blank" rel="noopener">C++20: The Three-Way Comparison Operator</a></li>
<li><a href="https://devblogs.microsoft.com/cppblog/simplify-your-code-with-rocket-science-c20s-spaceship-operator/" target="_blank" rel="noopener">Simplify Your Code With Rocket Science: C++20’s Spaceship Operator</a></li>
<li><a href="https://medium.com/nerd-for-tech/c-20-three-way-comparison-operator-part-1-60e2946ae4a3" target="_blank" rel="noopener">C++20 three-way comparison operator: Part 1</a></li>
<li><a href="https://medium.com/nerd-for-tech/c-20-three-way-comparison-operator-part-2-fd520fb75e00" target="_blank" rel="noopener">C++20 three-way comparison operator: Part 2</a></li>
<li><a href="https://medium.com/nerd-for-tech/c-20-three-way-comparison-operator-part-3-143ac397b3f1" target="_blank" rel="noopener">C++20 three-way comparison operator: Part 3</a></li>
<li><a href="https://medium.com/nerd-for-tech/c-20-three-way-comparison-operator-part-4-6a8ea2c0a3f0" target="_blank" rel="noopener">C++20 three-way comparison operator: Part 4</a></li>
<li><a href="https://medium.com/geekculture/c-20-three-way-comparison-operator-part-5-e986b5ab29d9" target="_blank" rel="noopener">C++20 three way comparison operator: Part 5</a></li>
<li><a href="https://medium.com/nerd-for-tech/c-20-three-way-comparison-operator-part-6-c66a173dcc99" target="_blank" rel="noopener">C++20 three way comparison operator: Part 6</a></li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/08/06/Customization-Point-Object-tag-invoke-and-future/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="HungMingWu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="第十三號艦隊">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/08/06/Customization-Point-Object-tag-invoke-and-future/" class="post-title-link" itemprop="url">Customization Point Object, tag_invoke and future</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-08-06 10:57:06" itemprop="dateCreated datePublished" datetime="2022-08-06T10:57:06+00:00">2022-08-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-10-06 01:47:17" itemprop="dateModified" datetime="2025-10-06T01:47:17+00:00">2025-10-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="namespace"><a href="#namespace" class="headerlink" title="namespace"></a>namespace</h3><p>由於繼承自C語言，所以會遇到像這樣的問題</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// my_std.h</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">// other_lib.h</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">baz</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>來自於不同的Library，且提供不同的實作，在使用上會出現一些問題<br>而C語言時代的解法就是對Function Name加料</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// my_std.h</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_std_foo</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">my_std_bar</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">// other_lib.h</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">other_lib_foo</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">other_lib_baz</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>而C++做的事情差不多，用namespace隔開</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// my_std.h</span></span><br><span class="line"><span class="keyword">namespace</span> my_std &#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// other_lib.h</span></span><br><span class="line"><span class="keyword">namespace</span> other_lib &#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">baz</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ADL"><a href="#ADL" class="headerlink" title="ADL"></a>ADL</h3><p>全名是<strong>Argument-Dependent Lookup</strong><br>只要有一個參數在函數的命名空間內，在使用的時候就不用加namespace prefix<br>在ADL只關心函數，<strong>不包含Function Object</strong>，這點在之後會用到</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> A</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Empty</span> &#123;</span>&#125;;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">(Empty, <span class="keyword">int</span>)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    A::foo(<span class="number">2</span>);</span><br><span class="line">    bar(A::Empty&#123;&#125;, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="number">1</span>; <span class="comment">// operator&lt;&lt; (std::cout, 1) Due to ADL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果沒有ADL，最後那行只能這樣寫了</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="keyword">operator</span>&lt;&lt;(<span class="built_in">std</span>::<span class="built_in">cout</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>應該沒人會喜歡</p>
<h3 id="Example-for-std-swap"><a href="#Example-for-std-swap" class="headerlink" title="Example for std::swap"></a>Example for std::swap</h3><p>這是拓展問題的最好範例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span> &#123;</span><br><span class="line">	<span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span> </span>&#123; </span><br><span class="line">		<span class="function">T <span class="title">temp</span><span class="params">(a)</span></span>; </span><br><span class="line">		a = b; </span><br><span class="line">		b = temp; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我們要對自己的class做swap動作時，該怎麼做</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> My &#123;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(A&amp;)</span> </span>&#123;&#125;</span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直覺的寫法可以這樣做</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">```cpp</span><br><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;&gt;</span><br><span class="line">    <span class="keyword">void</span> swap&lt;::My::A&gt;(::My::A&amp; a, ::My::A&amp; b) &#123;a.swap(b);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這樣寫是Undefined Beahvior<br>而另外一種做法是</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">std</span>::swap&lt;My::A&gt;(My::A&amp; a, My::A&amp; b) &#123; a.swap(b); &#125;</span><br></pre></td></tr></table></figure>
<p>不過如果是<code>My::A&lt;T&gt;</code>的話就不管用了<br>而比較常用的手法，就是利用ADL</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(...)</span></span>; <span class="comment">// 1 </span></span><br><span class="line"><span class="keyword">namespace</span> My &#123; </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">A</span>&#123;</span>&#125;; </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">const</span> A&amp;)</span></span>; <span class="comment">// 2 </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Code &#123; </span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span>)</span></span>; <span class="comment">// 3 </span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">use</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		::My::A a;</span><br><span class="line">		fun(a); <span class="comment">// HERE </span></span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>呼叫的<code>foo(a)</code>時，會考慮2和3，1是因為在Code的namespace已經找到一個fun了，部會在往上層的scope去尋找<br>利用<code>ADL two-step</code>的手法來拓展我們的<code>std::swap</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> My</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">A</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(A&amp; a, A&amp; b)</span> </span>&#123; a.swap(b); &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">B</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(B&amp; a, B&amp; b)</span> </span>&#123; a.swap(b); &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> Code</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">use</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">        ::My::A a1, a2;</span><br><span class="line">        swap(a1, a2); <span class="comment">// HERE #1</span></span><br><span class="line">        ::My::B&lt;<span class="keyword">int</span>&gt; b1, b2;</span><br><span class="line">        swap(b1, b2); <span class="comment">// HERE #2</span></span><br><span class="line">        <span class="keyword">int</span> i1, i2;</span><br><span class="line">        swap(i1, i2); <span class="comment">// NOPE</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在這個範例當中，呼叫swap的時候沒加上namespace，而讓<code>std::swap</code>注入當今的Scope下，如果可以透過ADL找到對應的函數，則用特化版的函數，不然就用原先的<code>std::swap</code>做預設值</p>
<h3 id="Drawback-on-ADL-two-step"><a href="#Drawback-on-ADL-two-step" class="headerlink" title="Drawback on ADL two-step"></a>Drawback on ADL two-step</h3><p>最大的問題在於</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">swap(a1, a2);</span><br></pre></td></tr></table></figure>
<p>可能一不小心就寫成</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::swap(a1, a2);</span><br></pre></td></tr></table></figure>
<p>不會報錯，頂多是效能差<br>另外一個比較大的問題是這個</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> __my_std_impl</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="keyword">auto</span> __distance_impl(T first, T last) &#123;<span class="comment">/* ... */</span>&#125;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">auto</span> <span class="title">distance</span><span class="params">(T first, T last)</span> </span>&#123;<span class="keyword">return</span> __distance_impl(first, last);&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">incomplete</span>;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">struct</span> <span class="title">box</span> &#123;</span>T value;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">use</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    incomplete* i = <span class="literal">nullptr</span>; <span class="comment">// fine</span></span><br><span class="line">    __my_std_impl::distance(i, i); <span class="comment">// fine</span></span><br><span class="line">    box&lt;incomplete&gt;* b = <span class="literal">nullptr</span>; <span class="comment">// fine</span></span><br><span class="line">    __my_std_impl::distance(b, b); <span class="comment">// !!!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>__my_std_impl::distance(b, b)</code>的地方會報錯<br>原因在於<code>__distance_impl</code>階段會進行ADL動作，在box的定義上尋找是否有<code>__distance_impl</code>的函數，因找到incomplete value，故報錯<br>一種可能的解法就是加上namespace</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">distance</span><span class="params">(T first, T last)</span> </span>&#123;<span class="keyword">return</span> __my_std_impl::__distance_impl(first, last);&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Customization-Point-Object"><a href="#Customization-Point-Object" class="headerlink" title="Customization Point Object"></a>Customization Point Object</h3><p>兩階段ADL的最大問題就是容易誤用<br>因此叫Standlard library來幫你做這件事<br>其中最簡單的CPO就長這樣</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>::ranges &#123;</span><br><span class="line">	<span class="keyword">inline</span> <span class="keyword">constexpr</span> swap = [](<span class="keyword">auto</span>&amp; a, <span class="keyword">auto</span>&amp; b) &#123; </span><br><span class="line">		<span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">		swap(a, b); </span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這裡的swap是個constexpr object，而不是個function，不過他是一個functor，因此可以適用於所有std::swap的環境下<br>CPO還有一個優勢，它是一個object，所以它能夠這樣用</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">some_ranges | views::transform(ranges::begin)</span><br></pre></td></tr></table></figure>
<p>而</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">some_ranges | views::transform(<span class="built_in">std</span>::begin)</span><br></pre></td></tr></table></figure>
<p>這樣用不合法，因為它是個template function</p>
<h3 id="Niebloids"><a href="#Niebloids" class="headerlink" title="Niebloids"></a>Niebloids</h3><p>Niebloids是要解決另外一個問題，去除掉不想要的ADL candicate<br>禁用的方法就是讓它成為CPO<br>以下是StackOverflow的範例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> mystd</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>&#125;;</span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(T &amp;a, T &amp;b)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"mystd::swap\n"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> sx</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">namespace</span> impl &#123;</span><br><span class="line">       <span class="comment">//our functor, the niebloid</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> __<span class="title">swap</span> &#123;</span></span><br><span class="line">            <span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> = <span class="built_in">std</span>::<span class="keyword">enable_if_t</span>&lt; <span class="built_in">std</span>::is_same&lt;R, mystd::A&gt;::value &gt;  &gt;</span><br><span class="line">            <span class="keyword">void</span> <span class="keyword">operator</span>()(R &amp;a, R &amp;b) <span class="keyword">const</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"in sx::swap()\n"</span>;</span><br><span class="line">                <span class="comment">// swap(a, b); </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">inline</span> <span class="keyword">constexpr</span> impl::__swap swap&#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    mystd::B a, b;</span><br><span class="line">    swap(a, b); <span class="comment">// calls mystd::swap()</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">using</span> <span class="keyword">namespace</span> sx;</span><br><span class="line">    mystd::A c, d;</span><br><span class="line">    swap(c, d); <span class="comment">//No ADL!, calls sx::swap!</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果找到的是function object，則不會使用ADL</p>
<h3 id="tag-invoke"><a href="#tag-invoke" class="headerlink" title="tag_invoke"></a>tag_invoke</h3><p>根據libunifex裡面的描述，一樣是透過ADL，要解決以下兩個問題</p>
<blockquote>
<ol>
<li>Each one internally dispatches via ADL to a free function of the same name, which has the effect of globally reserving that identifier (within some constraints). Two independent libraries that pick the same name for an ADL customization point still risk collision.  </li>
<li>There is occasionally a need to write wrapper types that ought to be transparent to customization. (Type-erasing wrappers are one such example.) With C++20’s CPOs, there is no way to generically forward customizations through the transparent wrap<br>比較大的問題是第一點，由於透過ADL尋找函數，所以每個namespace下都需要將函數名稱當作保留字</li>
</ol>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>::range &#123;</span><br><span class="line">	<span class="keyword">inline</span> <span class="keyword">constexpr</span> swap = [](<span class="keyword">auto</span>&amp; a, <span class="keyword">auto</span>&amp; b) &#123; </span><br><span class="line">		<span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">		swap(a, b); </span><br><span class="line">	&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">namespace</span> A &#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(...)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">nameapce B &#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(....)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也就是你用了swap當CPO之後，其他地方都要保留swap當作保留字不能使用，tag_invoke就是為了這點而生的<br>參考C++11 tag_invoke的實作 duck_invoke</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bfg/tag_invoke.h&gt;</span></span></span><br><span class="line"><span class="keyword">namespace</span> compute &#123;</span><br><span class="line">BFG_TAG_INVOKE_DEF(formula);</span><br><span class="line">&#125; <span class="comment">// namespace compute</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Compute&gt;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">do_compute</span><span class="params">(<span class="keyword">const</span> Compute &amp; c, <span class="keyword">float</span> a, <span class="keyword">float</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> compute::formula(c, a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">custom_compute</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">friend</span> <span class="keyword">float</span></span><br><span class="line">		tag_invoke(compute::<span class="keyword">formula_t</span>, <span class="keyword">const</span> custom_compute &amp;, <span class="keyword">float</span> a, <span class="keyword">float</span> b)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> a * b;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	do_compute(custom_compute&#123;&#125;, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要的作法是</p>
<ul>
<li>需要一個CPO參數，以上的範例是<code>formula</code></li>
<li>只需要一個tag_invoke function，不過可以Overloading，對不同的CPOj做不同的處理<br>不過tag_invoke製造了其他問題，難以理解且囉嗦</li>
</ul>
<h3 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h3><p>由於Executors跳票了，所以tag_invoke也不一定是最終解決方案<br>目前有其他提案，不過會不會被接受也在未定之天<br>詳細可以找找P2547R0來研究</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p><a href="https://www.zhihu.com/question/518132411" target="_blank" rel="noopener">如何理解 C++ 中的 定制点对象 这一概念？为什么要这样设计？</a><br><a href="https://zhuanlan.zhihu.com/p/431032074" target="_blank" rel="noopener">c++ execution 与 coroutine （一) : CPO与tag_invoke</a><br><a href="https://zhuanlan.zhihu.com/p/532859426" target="_blank" rel="noopener">C++特殊定制：揭秘cpo与tag_invoke！</a><br><a href="https://www.boost.org/doc/libs/1_77_0/libs/json/doc/html/json/dom/conversion.html#json.dom.conversion.customization_points" target="_blank" rel="noopener">Customization Points</a><br><a href="https://en.cppreference.com/w/cpp/language/adl" target="_blank" rel="noopener">Argument-dependent lookup - cppreference.com</a><br><a href="https://brevzin.github.io/c++/2020/12/01/tag-invoke/" target="_blank" rel="noopener">Why tag_invoke is not the solution I want (brevzin.github.io)</a><br><a href="https://stackoverflow.com/questions/62928396/what-is-a-niebloid" target="_blank" rel="noopener">What is a niebloid?</a><br><a href="https://zhuanlan.zhihu.com/p/374440385" target="_blank" rel="noopener">ADL，Concepts与扩展C++类库带来的思考</a><br><a href="https://www.bfgroup.xyz/duck_invoke/" target="_blank" rel="noopener">Duck Invoke — tag_invoke for C++11</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/06/04/Macro-in-Rust/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="HungMingWu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="第十三號艦隊">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/06/04/Macro-in-Rust/" class="post-title-link" itemprop="url">Macro in Rust</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-06-04 12:15:30" itemprop="dateCreated datePublished" datetime="2022-06-04T12:15:30+00:00">2022-06-04</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-10-06 01:47:17" itemprop="dateModified" datetime="2025-10-06T01:47:17+00:00">2025-10-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>寫了一堆CC++的文章，是時候換換口味了<br>Macro在Rust也有，不過不同於C/C++的Texture Replace<br>Rust的Macro強大的不得了，順便也跟C++的template做個比較</p>
<h3 id="Declarative-Macros"><a href="#Declarative-Macros" class="headerlink" title="Declarative Macros"></a>Declarative Macros</h3><h4 id="從min開始"><a href="#從min開始" class="headerlink" title="從min開始"></a>從min開始</h4><p>C macro版的min或是C++ templaate版的就不提供了，寫到不想寫了<br>直接看Rust的</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> min &#123;</span><br><span class="line">    ($a:ident, $b:ident) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> ($a &lt; $b) &#123;</span><br><span class="line">            $a</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $b</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">2u32</span>;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">3u32</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>,  min!(a, b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這樣看起來沒什麼特別的<br>那如果多加一個變數呢</p>
<h4 id="min-version2"><a href="#min-version2" class="headerlink" title="min version2"></a>min version2</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> min &#123;</span><br><span class="line">    ($a:ident, $b:ident) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> ($a &lt; $b) &#123;</span><br><span class="line">            $a</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            $b</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    ($a:ident, $b:ident, $c:ident) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> ($a &lt; $b) &#123;</span><br><span class="line">            <span class="keyword">if</span> ($a &lt; $c) &#123;</span><br><span class="line">                $a</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                $c</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ($b &lt; $c) &#123;</span><br><span class="line">                $b</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                $c</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">3u32</span>;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">2u32</span>;</span><br><span class="line">    <span class="keyword">let</span> c = <span class="number">1u32</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>,  min!(a, b, c));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同樣的macro，可以有兩種不同的使用方式意<br>C語言的marco板本長這樣</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min_2(a, b) ((a) &lt; (b)) ? (a) : (b)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min_3(a, b, c) ((a) &lt; (b)) ? ((a) &lt; (c)) ? (a) : (c) : ((b) &lt; (c)) ? (b) : (c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> GET_MACRO(_1,_2,_3,NAME,...) NAME</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(...) GET_MACRO(__VA_ARGS__, min_3, min_2)(__VA_ARGS__)</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d\n"</span>, <span class="built_in">min</span>(<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>));</span><br></pre></td></tr></table></figure>
<p>看起來就是一堆亂七八糟拼湊的組合怪<br>來看看Template版</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (a &lt; b) ? a : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">(T a, T b, T c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (a &lt; b) ? (a &lt; c) ? a : c : (b &lt; c) ? b : c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>憑藉於Function overloading，可讀性高很多，唯一比較麻煩的是要寫兩次template function declaration</p>
<h4 id="min-version3"><a href="#min-version3" class="headerlink" title="min version3"></a>min version3</h4><p>來個varadic個版本，先寫個看起來沒問題，實際上編譯不過的</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> min &#123;</span><br><span class="line">    ($a:ident) =&gt; &#123; $a &#125;;</span><br><span class="line">    ($a:ident, $($b:ident),+) =&gt; &#123;</span><br><span class="line">        <span class="keyword">let</span> minV = min!($($b),+)</span><br><span class="line">        <span class="keyword">if</span> ($a &lt; minV) &#123;</span><br><span class="line">            $a</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            minV</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>後來發現Rust Macro裡面不能有local variable，只能改成這樣</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> min &#123;</span><br><span class="line">    ($a:ident) =&gt; &#123; $a &#125;;</span><br><span class="line">    ($a:ident, $($b:ident),+) =&gt; &#123;</span><br><span class="line">        std::cmp::min($a, min!($($b),+))</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之後又發現一點和C/C++ preprocessor不同的地方，由於他是直接對AST做操作，所以得到的Token要自己Parse<br>所以做個實驗，參數之間分隔用<code>;</code>取代<code>,</code>，這樣是合法的</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">macro_rules!</span> min &#123;</span><br><span class="line">    ($a:ident) =&gt; &#123; $a &#125;;</span><br><span class="line">    ($a:ident; $($b:ident);+) =&gt; &#123;</span><br><span class="line">        std::cmp::min($a, min!($($b);+))</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">3u32</span>;</span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">2u32</span>;</span><br><span class="line">    <span class="keyword">let</span> c = <span class="number">1u32</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"&#123;&#125;"</span>,  min!(a; b; c));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不過沒辦法用local variable有點可惜，<br>Marco版的，我寫不出來，直接看Variadic Template的版本</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">T <span class="title">min</span><span class="params">(<span class="keyword">const</span> T&amp; first, <span class="keyword">const</span> Args&amp;... args)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">sizeof</span>...(Args) == <span class="number">0</span>)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">auto</span> minV = min(args...);</span><br><span class="line">                <span class="keyword">return</span> (first &lt; minV) ? first : minV;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以做更多的變化，不過Variadic Template最大的問題是我永遠記不住<code>...</code>到底要放哪這件事`<br>不過Rust真正厲害的是第二種Macro</p>
<h3 id="Procedural-Macros"><a href="#Procedural-Macros" class="headerlink" title="Procedural Macros"></a>Procedural Macros</h3><p>基本上就是把輸入的<code>TokenStream</code>轉成另外的<code>TokenStream</code>的流程</p>
<p>分成三種</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cargo new macro-demo --lib</span><br></pre></td></tr></table></figure>
<p>在<code>Cargo.toml</code>新增以下兩行</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[lib]</span></span><br><span class="line"><span class="attr">proc-macro</span> = <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h4 id="Attribute-macros"><a href="#Attribute-macros" class="headerlink" title="Attribute macros"></a>Attribute macros</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[proc_macro_attribute]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">sorted</span></span>(args: TokenStream, input: TokenStream) -&gt; TokenStream &#123;</span><br><span class="line">    <span class="keyword">let</span> _ = args;</span><br><span class="line">    <span class="keyword">let</span> _ = input;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unimplemented!</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>How to use atribute macro</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[sorted]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Letter</span></span> &#123;</span><br><span class="line">    A,</span><br><span class="line">    B,</span><br><span class="line">    C,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Function-like-procedural-macros"><a href="#Function-like-procedural-macros" class="headerlink" title="Function-like procedural macros"></a>Function-like procedural macros</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[proc_macro]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">seq</span></span>(input: TokenStream) -&gt; TokenStream &#123;</span><br><span class="line">    <span class="keyword">let</span> _ = input;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unimplemented!</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>How to use function-like macro</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">seq! &#123; n <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Derive-macro-helper-attributes"><a href="#Derive-macro-helper-attributes" class="headerlink" title="Derive macro helper attributes"></a>Derive macro helper attributes</h4><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[proc_macro_derive(Builder)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">derive_builder</span></span>(input: TokenStream) -&gt; TokenStream &#123;</span><br><span class="line">    <span class="keyword">let</span> _ = input;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unimplemented!</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>How to use derived macro</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Builder)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Command</span></span> &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="Caution"><a href="#Caution" class="headerlink" title="Caution"></a>Caution</h4><p><code>Procedural Macros</code>不同於<code>Declarative Macros</code>，必須單獨是一個crate存在，目前IDE對Proc Macro的支持度不好，連Debug Proc Macro也很麻煩，最常使用的還是print大法</p>
<h4 id="Simple-example"><a href="#Simple-example" class="headerlink" title="Simple  example"></a>Simple  example</h4><p>從別人的範例中學來的，這邊實作一個<code>Attribute macros</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir rust_proc_macro_demo &amp;&amp; <span class="built_in">cd</span> rust_proc_macro_demo</span><br><span class="line">$ mkdir rust_proc_macro_guide &amp;&amp; <span class="built_in">cd</span> rust_proc_macro_guide</span><br><span class="line">$ cargo init --bin</span><br><span class="line">$ <span class="built_in">cd</span> ..</span><br><span class="line">$ mkdir proc_macro_define_crate &amp;&amp; <span class="built_in">cd</span> proc_macro_define_crate</span><br><span class="line">$ cargo init --lib</span><br><span class="line">$ <span class="built_in">cd</span> ..</span><br></pre></td></tr></table></figure>
<p>修改<code>proc_macro_define_crate/Cargo.toml</code><br>加入</p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[lib]</span></span><br><span class="line"><span class="attr">proc-macro</span> = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">quote</span> = <span class="string">"1"</span></span><br><span class="line"><span class="attr">syn</span> = &#123;features=[<span class="string">"full"</span>,<span class="string">"extra-traits"</span>]&#125;</span><br></pre></td></tr></table></figure>

<p>接著修改<code>rust_proc_macro_guide/Cargo.toml</code></p>
<figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">proc_macro_define_crate</span> = &#123;path=<span class="string">"../proc_macro_define_crate"</span>&#125;</span><br></pre></td></tr></table></figure>
<p>置換掉<code>proc_macro_define_crate/src/lib.rs</code>裡面的內容</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> proc_macro::TokenStream;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[proc_macro_attribute]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">mytest_proc_macro</span></span>(attr: TokenStream, item: TokenStream) -&gt; TokenStream &#123;</span><br><span class="line">    eprintln!(<span class="string">"Attr &#123;:#?&#125;"</span>, attr);</span><br><span class="line">    eprintln!(<span class="string">"Item &#123;:#?&#125;"</span>, item);</span><br><span class="line">    item</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一樣將<code>rust_proc_macro_guide/src/main.rs</code>內部的內容換掉</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> proc_macro_define_crate::mytest_proc_macro;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[mytest_proc_macro(HungMingWu)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">foo</span></span>(a:<span class="built_in">i32</span>)&#123;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">"hello world"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接著用<code>cargo check</code>檢查</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> rust_proc_macro_guide/</span><br><span class="line">$ cargo check</span><br></pre></td></tr></table></figure>
<p>可以看到類似這樣的輸出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">Attr TokenStream [</span><br><span class="line">    Ident &#123;</span><br><span class="line">        ident: &quot;HungMingWu&quot;,</span><br><span class="line">        span: #0 bytes(69..79),</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br><span class="line">Item TokenStream [</span><br><span class="line">    Ident &#123;</span><br><span class="line">        ident: &quot;fn&quot;,</span><br><span class="line">        span: #0 bytes(82..84),</span><br><span class="line">    &#125;,</span><br><span class="line">    Ident &#123;</span><br><span class="line">        ident: &quot;foo&quot;,</span><br><span class="line">        span: #0 bytes(85..88),</span><br><span class="line">    &#125;,</span><br><span class="line">    Group &#123;</span><br><span class="line">        delimiter: Parenthesis,</span><br><span class="line">        stream: TokenStream [</span><br><span class="line">            Ident &#123;</span><br><span class="line">                ident: &quot;a&quot;,</span><br><span class="line">                span: #0 bytes(89..90),</span><br><span class="line">            &#125;,</span><br><span class="line">            Punct &#123;</span><br><span class="line">                ch: &#39;:&#39;,</span><br><span class="line">                spacing: Alone,</span><br><span class="line">                span: #0 bytes(90..91),</span><br><span class="line">            &#125;,</span><br><span class="line">            Ident &#123;</span><br><span class="line">                ident: &quot;i32&quot;,</span><br><span class="line">                span: #0 bytes(91..94),</span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">        span: #0 bytes(88..95),</span><br><span class="line">    &#125;,</span><br><span class="line">    Group &#123;</span><br><span class="line">        delimiter: Brace,</span><br><span class="line">        stream: TokenStream [</span><br><span class="line">            Ident &#123;</span><br><span class="line">                ident: &quot;println&quot;,</span><br><span class="line">                span: #0 bytes(101..108),</span><br><span class="line">            &#125;,</span><br><span class="line">            Punct &#123;</span><br><span class="line">                ch: &#39;!&#39;,</span><br><span class="line">                spacing: Alone,</span><br><span class="line">                span: #0 bytes(108..109),</span><br><span class="line">            &#125;,</span><br><span class="line">            Group &#123;</span><br><span class="line">                delimiter: Parenthesis,</span><br><span class="line">                stream: TokenStream [</span><br><span class="line">                    Literal &#123;</span><br><span class="line">                        kind: Str,</span><br><span class="line">                        symbol: &quot;hello world&quot;,</span><br><span class="line">                        suffix: None,</span><br><span class="line">                        span: #0 bytes(110..123),</span><br><span class="line">                    &#125;,</span><br><span class="line">                ],</span><br><span class="line">                span: #0 bytes(109..124),</span><br><span class="line">            &#125;,</span><br><span class="line">            Punct &#123;</span><br><span class="line">                ch: &#39;;&#39;,</span><br><span class="line">                spacing: Alone,</span><br><span class="line">                span: #0 bytes(124..125),</span><br><span class="line">            &#125;,</span><br><span class="line">        ],</span><br><span class="line">        span: #0 bytes(95..127),</span><br><span class="line">    &#125;,</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>這樣我們就能看出Attr和Item分別對應的TokenStream了</p>
<h4 id="From-TokenStream-to-Syntax-Tree"><a href="#From-TokenStream-to-Syntax-Tree" class="headerlink" title="From TokenStream to Syntax Tree"></a>From TokenStream to Syntax Tree</h4><p>有些時候，光看Lexer的TokenStream無助於解決問題，我們需要Syntax Tree<br>因此我們修改<code>mytest_proc_macro</code></p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> proc_macro::TokenStream;</span><br><span class="line"><span class="keyword">use</span> syn::&#123;parse_macro_input, AttributeArgs, Item&#125;;</span><br><span class="line"><span class="keyword">use</span> quote::quote;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[proc_macro_attribute]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">mytest_proc_macro</span></span>(attr: TokenStream, item: TokenStream) -&gt; TokenStream &#123;</span><br><span class="line">    eprintln!(<span class="string">"Attr &#123;:#?&#125;"</span>, parse_macro_input!(attr <span class="keyword">as</span> AttributeArgs));</span><br><span class="line">    <span class="keyword">let</span> body_ast = parse_macro_input!(item <span class="keyword">as</span> Item);</span><br><span class="line">    eprintln!(<span class="string">"Item &#123;:#?&#125;"</span>, body_ast);</span><br><span class="line">    quote!(#body_ast).into()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>會跑出這樣的結果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line">Attr [</span><br><span class="line">    Meta(</span><br><span class="line">        Path(</span><br><span class="line">            Path &#123;</span><br><span class="line">                leading_colon: None,</span><br><span class="line">                segments: [</span><br><span class="line">                    PathSegment &#123;</span><br><span class="line">                        ident: Ident &#123;</span><br><span class="line">                            ident: &quot;HungMingWu&quot;,</span><br><span class="line">                            span: #0 bytes(69..79),</span><br><span class="line">                        &#125;,</span><br><span class="line">                        arguments: None,</span><br><span class="line">                    &#125;,</span><br><span class="line">                ],</span><br><span class="line">            &#125;,</span><br><span class="line">        ),</span><br><span class="line">    ),</span><br><span class="line">]</span><br><span class="line">Item Fn(</span><br><span class="line">    ItemFn &#123;</span><br><span class="line">        attrs: [],</span><br><span class="line">        vis: Inherited,</span><br><span class="line">        sig: Signature &#123;</span><br><span class="line">            constness: None,</span><br><span class="line">            asyncness: None,</span><br><span class="line">            unsafety: None,</span><br><span class="line">            abi: None,</span><br><span class="line">            fn_token: Fn,</span><br><span class="line">            ident: Ident &#123;</span><br><span class="line">                ident: &quot;foo&quot;,</span><br><span class="line">                span: #0 bytes(85..88),</span><br><span class="line">            &#125;,</span><br><span class="line">            generics: Generics &#123;</span><br><span class="line">                lt_token: None,</span><br><span class="line">                params: [],</span><br><span class="line">                gt_token: None,</span><br><span class="line">                where_clause: None,</span><br><span class="line">            &#125;,</span><br><span class="line">            paren_token: Paren,</span><br><span class="line">            inputs: [</span><br><span class="line">                Typed(</span><br><span class="line">                    PatType &#123;</span><br><span class="line">                        attrs: [],</span><br><span class="line">                        pat: Ident(</span><br><span class="line">                            PatIdent &#123;</span><br><span class="line">                                attrs: [],</span><br><span class="line">                                by_ref: None,</span><br><span class="line">                                mutability: None,</span><br><span class="line">                                ident: Ident &#123;</span><br><span class="line">                                    ident: &quot;a&quot;,</span><br><span class="line">                                    span: #0 bytes(89..90),</span><br><span class="line">                                &#125;,</span><br><span class="line">                                subpat: None,</span><br><span class="line">                            &#125;,</span><br><span class="line">                        ),</span><br><span class="line">                        colon_token: Colon,</span><br><span class="line">                        ty: Path(</span><br><span class="line">                            TypePath &#123;</span><br><span class="line">                                qself: None,</span><br><span class="line">                                path: Path &#123;</span><br><span class="line">                                    leading_colon: None,</span><br><span class="line">                                    segments: [</span><br><span class="line">                                        PathSegment &#123;</span><br><span class="line">                                            ident: Ident &#123;</span><br><span class="line">                                                ident: &quot;i32&quot;,</span><br><span class="line">                                                span: #0 bytes(91..94),</span><br><span class="line">                                            &#125;,</span><br><span class="line">                                            arguments: None,</span><br><span class="line">                                        &#125;,</span><br><span class="line">                                    ],</span><br><span class="line">                                &#125;,</span><br><span class="line">                            &#125;,</span><br><span class="line">                        ),</span><br><span class="line">                    &#125;,</span><br><span class="line">                ),</span><br><span class="line">            ],</span><br><span class="line">            variadic: None,</span><br><span class="line">            output: Default,</span><br><span class="line">        &#125;,</span><br><span class="line">        block: Block &#123;</span><br><span class="line">            brace_token: Brace,</span><br><span class="line">            stmts: [</span><br><span class="line">                Semi(</span><br><span class="line">                    Macro(</span><br><span class="line">                        ExprMacro &#123;</span><br><span class="line">                            attrs: [],</span><br><span class="line">                            mac: Macro &#123;</span><br><span class="line">                                path: Path &#123;</span><br><span class="line">                                    leading_colon: None,</span><br><span class="line">                                    segments: [</span><br><span class="line">                                        PathSegment &#123;</span><br><span class="line">                                            ident: Ident &#123;</span><br><span class="line">                                                ident: &quot;println&quot;,</span><br><span class="line">                                                span: #0 bytes(101..108),</span><br><span class="line">                                            &#125;,</span><br><span class="line">                                            arguments: None,</span><br><span class="line">                                        &#125;,</span><br><span class="line">                                    ],</span><br><span class="line">                                &#125;,</span><br><span class="line">                                bang_token: Bang,</span><br><span class="line">                                delimiter: Paren(</span><br><span class="line">                                    Paren,</span><br><span class="line">                                ),</span><br><span class="line">                                tokens: TokenStream [</span><br><span class="line">                                    Literal &#123;</span><br><span class="line">                                        kind: Str,</span><br><span class="line">                                        symbol: &quot;hello world&quot;,</span><br><span class="line">                                        suffix: None,</span><br><span class="line">                                        span: #0 bytes(110..123),</span><br><span class="line">                                    &#125;,</span><br><span class="line">                                ],</span><br><span class="line">                            &#125;,</span><br><span class="line">                        &#125;,</span><br><span class="line">                    ),</span><br><span class="line">                    Semi,</span><br><span class="line">                ),</span><br><span class="line">            ],</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h4 id="Comparsion-with-C-C"><a href="#Comparsion-with-C-C" class="headerlink" title="Comparsion with C/C++"></a>Comparsion with C/C++</h4><p>要達到類似的功能，除了X-Macros之外，我想不到類似的方法了<br>不過X-Marcos不僅醜，功能還有限，Debug更困難</p>
<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><p>–  <a href="https://zhuanlan.zhihu.com/p/106016118" target="_blank" rel="noopener">Rust Macro 手册</a><br>– <a href="http://blog.hubwiz.com/2020/01/30/rust-macro/" target="_blank" rel="noopener">Rust宏编程新手指南【Macro】</a><br>– <a href="https://www.kilerd.me/rust-proc-macro-101/" target="_blank" rel="noopener">Rust 过程宏 101</a><br>– <a href="https://veykril.github.io/tlborm/introduction.html#the-little-book-of-rust-macros" target="_blank" rel="noopener">The Little Book of Rust Macros</a><br>– <a href="https://github.com/dtolnay/proc-macro-workshop/" target="_blank" rel="noopener">Rust Latam: procedural macros workshop</a><br>– <a href="https://blog.logrocket.com/macros-in-rust-a-tutorial-with-examples/" target="_blank" rel="noopener">Macros in Rust: A tutorial with examples - LogRocket Blog</a><br>– <a href="https://stackoverflow.com/questions/11761703/overloading-macro-on-number-of-arguments" target="_blank" rel="noopener">Overloading Macro on Number of Arguments</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/02/27/ScopeExit-and-Higher-Order-Function-in-C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="HungMingWu">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="第十三號艦隊">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2022/02/27/ScopeExit-and-Higher-Order-Function-in-C/" class="post-title-link" itemprop="url">ScopeExit and Higher Order Function in C++</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2022-02-27 19:57:02" itemprop="dateCreated datePublished" datetime="2022-02-27T19:57:02+00:00">2022-02-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2025-10-06 01:47:17" itemprop="dateModified" datetime="2025-10-06T01:47:17+00:00">2025-10-06</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Story"><a href="#Story" class="headerlink" title="Story"></a>Story</h3><p>故事起源來自於看到類似這樣的程式碼</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VL_RESTORER(var) \</span></span><br><span class="line">    <span class="keyword">const</span> VRestorer&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::decay&lt;<span class="keyword">decltype</span>(var)&gt;::type&gt; restorer_#<span class="meta">#var(var);</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">VRestorer</span> &#123;</span></span><br><span class="line">    T&amp; m_ref;</span><br><span class="line">    <span class="keyword">const</span> T m_saved;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">VRestorer</span><span class="params">(T&amp; permr)</span></span></span><br><span class="line"><span class="function">        : m_ref</span>&#123;permr&#125;</span><br><span class="line">        , m_saved&#123;permr&#125; &#123;&#125;</span><br><span class="line">    ~VRestorer() &#123; m_ref = m_saved; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>利用RAII來保存上下文當前的值，執行到結束的時候恢復原狀<br>不過</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line">VL_RESTORER(a);</span><br><span class="line">VL_RESTORER(b);</span><br><span class="line">a = <span class="number">3</span>;</span><br><span class="line">b = <span class="number">4</span>;</span><br></pre></td></tr></table></figure>
<p>用起來沒什麼問題，不過總要找個題目來練習</p>
<h3 id="ScopeExit"><a href="#ScopeExit" class="headerlink" title="ScopeExit"></a>ScopeExit</h3><p>基本上就是RAII的變形，在Destructor的部分執行我們需要的Function，隨便在github搜尋就一堆了，這邊有個最簡單的方案</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">scope_exit</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    F f;</span><br><span class="line">    ~scope_exit() &#123; f(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> scope_exit&lt;F&gt; <span class="title">make_scope_exit</span><span class="params">(F&amp;&amp; f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope_exit&lt;F&gt;&#123;f&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果使用上C++17的CTAD，底下的<code>make_scope_exit</code>也不一定得存在</p>
<p>所以問題就變成了這樣，我希望在結束的時候，將<strong>所存的變數恢復原狀</strong><br>問題就變成了該怎麼做</p>
<h3 id="Higher-Order-Function"><a href="#Higher-Order-Function" class="headerlink" title="Higher Order Function"></a>Higher Order Function</h3><p>雖然C++不是標準的Functional Programming Language，不過要做點手腳還是辦得到的<br>問題變成了，傳入需要保存狀態的變數，回傳是一個函數，執行這個函數就能恢復原狀，這裡用上了Variadic Template和Tuple</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ...Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">auto</span> <span class="title">restore</span><span class="params">(Ts&amp;&amp; ...ts)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> [restore_ref = <span class="built_in">std</span>::tuple&lt;<span class="built_in">std</span>::<span class="keyword">add_lvalue_reference_t</span>&lt;<span class="built_in">std</span>::<span class="keyword">decay_t</span>&lt;Ts&gt;&gt;...&gt;(<span class="built_in">std</span>::forward&lt;Ts&gt;(ts)...),</span><br><span class="line">                store = <span class="built_in">std</span>::tuple&lt;<span class="built_in">std</span>::<span class="keyword">add_const_t</span>&lt;<span class="built_in">std</span>::<span class="keyword">decay_t</span>&lt;Ts&gt;&gt;...&gt;(ts...)]() <span class="keyword">mutable</span> <span class="keyword">noexcept</span></span><br><span class="line">        &#123;</span><br><span class="line">                        restore_ref = store;</span><br><span class="line">        &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>這邊有兩個tuple，其中restore_ref保存了所有變數的reference，store則是變數這個時間點的值</p>
<h3 id="Combo"><a href="#Combo" class="headerlink" title="Combo"></a>Combo</h3><p>上面的方式能夠寫成</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">auto</span> _ = make_scope_exit(restore(a, b));</span><br><span class="line">a = <span class="number">3</span>;</span><br><span class="line">b = <span class="number">4</span>;</span><br></pre></td></tr></table></figure>

<p>好壞就見仁見智了</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/26/">26</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          
<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">HungMingWu</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">258</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">148</span>
        <span class="site-state-item-name">categories</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">HungMingWu</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
